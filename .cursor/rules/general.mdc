---
alwaysApply: true
---

# AI Instructions & Prompts (A setup routine for Coding AI's)

> **Scope**: This applies to ALL tasks. Always active.

**Project Nature**: This is a **meta-project** that creates AI rules, processes, and prompts for end users to configure in their own projects.

**Project Goals**: 
- Users **MUST** be able to setup AI rules, borders, and prompts for multiple AI tools via setup scripts for their new or existing projects
- Provide rules and processes in each toolâ€™s native format (modular rules where supported, or a single concatenated instruction file where required)
- All files for rules and processes **MUST** be token efficient and understandable for all AI's at the same time!
- **NEVER** work with fixed versions. Use user's project-related versions and make it flexible (read from `.nvmrc`, `global.json`, `pom.xml`, etc.)
- Files **MUST** follow the same structure for a better maintainability
- All rules and processes **MUST** be understandable the same way for all AI's - The goal is to have the same result no matter which AI is used

**Supported AI Tools** (10 total):
- Cursor (modular rules with glob patterns)
- Claude (always-on instructions + modular path-specific rules)
- GitHub Copilot (repository-level instructions)
- Windsurf (single concatenated rules file)
- Aider (conventions file)
- Google AI Studio (single concatenated instructions file)
- Amazon Q Developer (single concatenated instructions file)
- Tabnine (single concatenated instructions file)
- Cody / Sourcegraph (repository-level instructions)
- Continue.dev (editor instructions file)

**Project Structure** (source content in this repository):
- Rules library: hierarchical rules (general â†’ language â†’ framework â†’ structure â†’ security)
- Processes library: step-by-step implementation guides (testing, CI/CD, logging, docker, auth, migrations, API docs)
- Functions library: cross-language implementation patterns (5-20 lines each, reduces AI guessing)
  - Functions index: quick reference for all function patterns
  - One file per pattern, all 8 languages in same file for comparison
  - Examples: error-handling, async-operations, input-validation, database-query, http-requests, logging, caching, config-secrets, auth-authorization, rate-limiting, webhooks
- Setup scripts: interactive setup for Bash and PowerShell
- Config: metadata for all languages, frameworks, structures, and processes
- State file (in the target project root): last setup selection for safe reruns (add/remove languages/tools)

**Success Criteria** - "Same Result" means:
- Consistent code structure and architecture patterns
- Same security practices applied (OWASP Top 10, input validation, etc.)
- Same testing approaches (unit, integration, mocking)
- Same CI/CD best practices (version detection, caching, matrix testing)
- Not byte-for-byte identical, but architecturally equivalent

**ðŸš¨ CRITICAL RULE - Check Functions BEFORE Generating Code**

> **BEFORE** implementing error handling, async operations, input validation, database queries, HTTP requests, or other covered function patterns:
>
> 1. **CHECK** the custom functions index **if it exists**
> 2. **THEN CHECK** the core functions index
> 3. **USE** the exact pattern from the function file (e.g., `error-handling.md`)
> 4. **CHOOSE** the appropriate framework version (Plain, Prisma, Laravel, etc.)
> 5. **COPY** the exact code pattern (no installation commands)
>
> **DO NOT** waste tokens generating code from scratch when patterns exist.
> **DO NOT** guess implementations - use proven, secure patterns.
>
> This saves 70-80% of tokens and ensures consistent, secure code across all projects.

---

**Key Principles** (Priority Order):

1. **Cross-AI Understandability** (PRIMARY GOAL)
   - **ALWAYS** prioritize clarity over brevity
   - **ALWAYS** test mental model: "Would GPT-3.5, GPT-4, Claude, Gemini, and Codestral understand this the SAME way?"
   - **ALWAYS** provide enough context and examples for consistent interpretation
   - **ALWAYS** use explicit directives: `> **ALWAYS**` and `> **NEVER**`
   - **ALWAYS** include concrete examples when ambiguity is possible
   - **NEVER** sacrifice clarity for token count
   - **NEVER** use line counts as hard limits (15 lines or 150 lines - both OK if clear)
   - Goal: Same architectural result across all AIs
   
   **Clarity Evaluation Criteria** (not line count):
   - Can two different AIs produce architecturally equivalent results from this?
   - Are directives explicit enough (`> **ALWAYS**` / `> **NEVER**` format)?
   - Is there an AI Self-Check section (helps all AIs validate)?
   - Are there concrete examples (not just prose)?
   - Would GPT-3.5 understand this the SAME as Claude/GPT-4?
   - Any room for different interpretations?

2. **Token Efficiency** (SECONDARY - only where clarity is maintained)
   - Prefer concise directives over verbose paragraphs (if equally clear)
   - Use tables instead of prose for comparisons (better structure)
   - Prefer pattern names over code examples (if pattern is well-known)
   - Code examples: 5-15 lines (key pattern only, not 50+ line examples)
   - Remove verbosity: "In order to achieve X, you should consider Y" â†’ "**ALWAYS**: Use Y for X"
   - **No hard line count limits**: A clear 20-line file is better than a confusing 80-line file
   - **When to add content**: Missing directives, no AI Self-Check, ambiguous patterns
   - **When to condense**: Verbose prose, 50+ line code examples, repeated explanations

3. **Consistency & Structure**
   - Pattern-based: Consistent format across all files
   - Self-validating: AI Self-Check sections with 10-12 items
   - Git Workflow reference pattern to avoid repetition
   - Same section order across similar file types

4. **Change Propagation** (CRITICAL - Keep the meta-project consistent)
   - **Whenever you change ANYTHING**, you **MUST** evaluate and update all dependent parts.
   - **ALWAYS** assume a change can require updates in:
     - setup scripts (generation logic, new/renamed outputs, paths)
     - state file behavior (rerun UX, defaults, backwards compatibility)
     - config metadata (languages/tools/frameworks/structures/processes mappings)
     - language/framework/structure rule sources (from this repo)
     - processes library (permanent and on-demand processes)
     - functions library + functions index (patterns and index)
     - root docs and tool setup docs (readme, customization, troubleshooting)
   - **NEVER** leave docs/scripts pointing to old paths or concepts.
   - **ALWAYS** update the generated outputs for the supported AI tools when applicable (see **Supported AI Tools** above).

## Rerunnable Setup (CRITICAL)

> **ALWAYS** treat setup as rerunnable and safe to re-run in existing projects.

- **State**: Setup persists the userâ€™s last selection to `.ai-iap-state.json` (in the project root).
- **Safe cleanup**: Generated outputs that can be cleaned must be marked:
  - Cursor rules (`.cursor/rules/**/*.mdc`): frontmatter includes `aiIapManaged: true`
  - Claude modular rules (`.claude/rules/**/*.md`): frontmatter includes `aiIapManaged: true`
  - Single-file outputs (e.g. `.windsurfrules`): include the generated header comment so cleanup can detect ownership
- **NEVER** delete user-owned files during cleanup unless they are clearly marked as generated by this tool.

5. **Functions System** (CRITICAL - Reduce AI Guessing & Token Waste)
   - **Purpose**: Provide exact implementation patterns across all 8 languages to reduce token consumption and guessing
   - **Location**: Functions library (in this repo / copied into projects that keep the source folder)
   - **Structure**: ONE file per pattern, ALL languages in same file
   - **Index**: Quick lookup table - **ALWAYS CHECK THE INDEX FIRST** before implementing common patterns
   - **Template**: **ALWAYS** start new function files from the functions template
     - **MUST** keep the same YAML frontmatter keys/structure
     - **MUST** keep code examples as the only content after the YAML header (no long explanations, no install commands)
     - **MUST** add the new file to the functions index
   
   **ðŸš¨ MANDATORY RULE FOR ALL AIs:**
   
  > **BEFORE** implementing ANY of these patterns, **CHECK** the functions index and use the provided pattern
   > **DO NOT GUESS** or generate code from scratch if a function pattern exists.
   > **DO NOT WASTE TOKENS** generating what already exists in `/functions/`.
   
   - **When to use**: ALWAYS check before implementing any covered function pattern
   - **How to use**: 
     1. Check `INDEX.md` for pattern availability
     2. Open relevant function file (e.g., `error-handling.md`)
     3. Choose appropriate framework/library version for the project
     4. Copy exact code pattern (no installation commands)
   - **Benefits**: Consistent code, 70-80% less token waste, fewer bugs, faster development
   - **Pattern**: Each function file shows TypeScript, Python, Java, C#, PHP, Kotlin, Swift, Dart with 2-4 framework versions each
   
6. **File Scope & Pattern Lookup**
   - **ALWAYS** analyze and work on all relevant source files and any project customizations
   - **ALWAYS** check the projectâ€™s existing dependencies before choosing a framework/library variant
   - **NEVER** add installation commands to function files (functions are code-only after YAML frontmatter)
   - **ALWAYS** check the functions index **BEFORE** implementing patterns
   - **NEVER** generate these patterns from scratch - use the provided implementations
